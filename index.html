<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Electric Music Generator</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
      height: 100%;
    }
    #ui {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #00bfff;
      padding: 20px 30px;
      border-radius: 15px;
      text-align: center;
      color: #00bfff;
      z-index: 10;
    }
    label, select, button {
      font-size: 1.3em;
      margin: 10px;
      background: black;
      color: #00bfff;
      border: 1px solid #00bfff;
      border-radius: 8px;
      padding: 5px 10px;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
  </style>
</head>
<body>
  <div id="ui">
    <label for="instrument">Instrument:</label>
    <select id="instrument">
      <option value="synth">Synth</option>
      <option value="bell">Bell</option>
      <option value="piano">Piano</option>
      <option value="choir">Choir</option>
    </select><br />
    <button onclick="startMusic()">Start</button>
    <button onclick="stopMusic()">Stop</button>
  </div>
  <canvas id="bg"></canvas>

  <script>
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = window.innerWidth;
    let h = canvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
    });

    const dots = Array.from({ length: 100 }, () => ({
      x: Math.random() * w,
      y: Math.random() * h,
      vx: (Math.random() - 0.5) * 0.3,
      vy: (Math.random() - 0.5) * 0.3
    }));

    function drawBackground() {
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.fillRect(0, 0, w, h);

      for (let i = 0; i < dots.length; i++) {
        const a = dots[i];
        a.x += a.vx;
        a.y += a.vy;
        if (a.x < 0 || a.x > w) a.vx *= -1;
        if (a.y < 0 || a.y > h) a.vy *= -1;

        ctx.beginPath();
        ctx.arc(a.x, a.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = '#00bfff';
        ctx.fill();

        for (let j = i + 1; j < dots.length; j++) {
          const b = dots[j];
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 100) {
            ctx.strokeStyle = `rgba(0,191,255, ${1 - dist / 100})`;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        }
      }
      requestAnimationFrame(drawBackground);
    }

    drawBackground();

    // Audio logic
    let audioCtx;
    let musicInterval = null;

    function playTone(frequency, instrument) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      // Configure oscillator
      osc.type = 'sine';

      // Apply custom waveform based on selected instrument
      switch (instrument) {
        case 'synth':
          osc.type = 'sine';
          break;
        case 'bell':
          osc.type = 'sine';
          break;
        case 'piano':
          osc.type = 'triangle';
          break;
        case 'choir':
          osc.type = 'sawtooth';
          break;
      }

      osc.frequency.value = frequency;
      gain.gain.setValueAtTime(0.01 + Math.random() * 0.02, audioCtx.currentTime);

      // Instrumental envelope
      if (instrument === 'bell') {
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 2);
      } else if (instrument === 'choir') {
        gain.gain.linearRampToValueAtTime(0.001, audioCtx.currentTime + 2.5);
      } else {
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 1.5);
      }

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start();
      osc.stop(audioCtx.currentTime + 3);
    }

    function startMusic() {
      const instrument = document.getElementById("instrument").value;

      if (!audioCtx || audioCtx.state === 'closed') {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      if (!musicInterval) {
        musicInterval = setInterval(() => {
          // Play layered tones
          for (let i = 0; i < 3; i++) {
            const base = 200 + Math.random() * 300;
            const detune = (Math.random() - 0.5) * 20;
            playTone(base + detune, instrument);
          }
        }, 1800);
      }
    }

    function stopMusic() {
      if (musicInterval) {
        clearInterval(musicInterval);
        musicInterval = null;
      }
      if (audioCtx && audioCtx.close) {
        audioCtx.close();
      }
    }
  </script>
</body>
</html>
