<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Electric Music Generator</title>
  <style>
    body {
      margin: 0;
      background: black;
      font-family: 'Segoe UI', sans-serif;
      color: #cceaff;
      overflow: hidden;
    }
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    #ui {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 1;
    }
    select,
    button {
      background-color: #001f33;
      border: 2px solid #00aaff;
      color: white;
      font-size: 18px;
      padding: 10px 20px;
      margin: 10px;
      border-radius: 10px;
      cursor: pointer;
    }
    h1 {
      font-size: 42px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00ffff;
    }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>
  <div id="ui">
    <h1>Electric Music Generator</h1>
    <select id="instrument">
      <option value="synth">Synth (Smooth)</option>
      <option value="flute">Flute</option>
      <option value="piano">Piano</option>
      <option value="bell">Bell</option>
      <option value="choir">Choir</option>
    </select>
    <br />
    <button onclick="startMusic()">Start Audio</button>
    <button onclick="stopMusic()">Stop Audio</button>
  </div>

  <script>
    // ======= VISUALS =======
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');
    let width, height;
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    class Dot {
      constructor() {
        this.reset();
      }
      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.vx = (Math.random() - 0.5) * 0.2;
        this.vy = (Math.random() - 0.5) * 0.2;
        this.size = 1 + Math.random() * 2;
        this.alpha = 0.3 + Math.random() * 0.7;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < 0 || this.x > width) this.vx *= -1;
        if (this.y < 0 || this.y > height) this.vy *= -1;
      }
      draw() {
        ctx.beginPath();
        const glowRadius = this.size * 6;
        let grad = ctx.createRadialGradient(
          this.x,
          this.y,
          this.size * 0.5,
          this.x,
          this.y,
          glowRadius
        );
        grad.addColorStop(0, `rgba(0, 180, 255, ${this.alpha})`);
        grad.addColorStop(1, 'rgba(0, 180, 255, 0)');
        ctx.fillStyle = grad;
        ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    const dots = [];
    const DOT_COUNT = 90;
    for (let i = 0; i < DOT_COUNT; i++) dots.push(new Dot());

    function drawLines() {
      for (let i = 0; i < DOT_COUNT; i++) {
        const a = dots[i];
        for (let j = i + 1; j < DOT_COUNT; j++) {
          const b = dots[j];
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 150) {
            const alpha = 0.25 * (1 - dist / 150);
            ctx.strokeStyle = `rgba(0, 180, 255, ${alpha})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        }
      }
    }

    function animate() {
      ctx.clearRect(0, 0, width, height);
      for (const d of dots) {
        d.update();
        d.draw();
      }
      drawLines();
      requestAnimationFrame(animate);
    }
    animate();

    // ======= AUDIO =======
    let audioCtx;
    let isPlaying = false;
    let currentVoices = [];

    // Settings per instrument for base osc type & filter frequency
    function getInstrumentSettings(name) {
      switch (name) {
        case 'flute':
          return { type: 'sine', filterFreq: 1400 };
        case 'piano':
          return { type: 'triangle', filterFreq: 1100 };
        case 'bell':
          return { type: 'square', filterFreq: 1800 };
        case 'choir':
          return { type: 'sawtooth', filterFreq: 900 };
        default:
          return { type: 'sine', filterFreq: 2800 }; // synth smooth
      }
    }

    // Gentle, slow noise-based smoothness generator (returns value in 0-1)
    function smoothRandom(prev) {
      const change = (Math.random() - 0.5) * 0.06;
      let next = prev + change;
      if (next > 1) next = 1;
      if (next < 0) next = 0;
      return next;
    }

    // Layer voice class with two oscillators detuned gently, smooth envelopes
    class Voice {
      constructor(freq, instrumentSettings) {
        this.freq = freq;
        this.settings = instrumentSettings;

        this.osc1 = audioCtx.createOscillator();
        this.osc2 = audioCtx.createOscillator();
        this.gainNode = audioCtx.createGain();
        this.filter = audioCtx.createBiquadFilter();

        this.osc1.type = this.settings.type;
        this.osc2.type = this.settings.type;
        this.osc2.detune.value = 10; // slight detune for layering

        this.filter.type = 'lowpass';
        this.filter.frequency.value = this.settings.filterFreq;
        this.filter.Q.value = 5;

        this.osc1.connect(this.filter);
        this.osc2.connect(this.filter);
        this.filter.connect(this.gainNode);
        this.gainNode.connect(audioCtx.destination);

        this.osc1.frequency.setValueAtTime(this.freq, audioCtx.currentTime);
        this.osc2.frequency.setValueAtTime(this.freq * 1.01, audioCtx.currentTime);

        this.gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
        this.gainNode.gain.linearRampToValueAtTime(0.07, audioCtx.currentTime + 1);

        this.osc1.start();
        this.osc2.start();

        this.startTime = audioCtx.currentTime;
        this.alive = true;
      }
      update(freq, cutoff) {
        if (!this.alive) return;
        const now = audioCtx.currentTime;

        // Smooth freq changes with exponential approach
        this.osc1.frequency.setTargetAtTime(freq, now, 0.1);
        this.osc2.frequency.setTargetAtTime(freq * 1.01, now, 0.1);

        // Smooth filter cutoff changes
        this.filter.frequency.setTargetAtTime(cutoff, now, 0.2);
      }
      stop() {
        if (!this.alive) return;
        const now = audioCtx.currentTime;
        this.gainNode.gain.cancelScheduledValues(now);
        this.gainNode.gain.setTargetAtTime(0, now, 1.5);
        this.osc1.stop(now + 2);
        this.osc2.stop(now + 2);
        this.alive = false;
      }
    }

    let calmness = 0.5; // 0..1 controls chaos and high pitch presence

    let lastFreq = 300;
    let lastCutoff = 1000;

    function startMusic() {
      if (isPlaying) return;
      isPlaying = true;

      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const instrument = document.getElementById('instrument').value;
      const settings = getInstrumentSettings(instrument);

      function generateNote() {
        if (!isPlaying) return;

        // Slowly vary calmness to build/reduce chaos
        calmness = smoothRandom(calmness);

        // Frequency base, weighted by calmness (less chaos = fewer high pitches)
        const baseFreq = 150 + calmness * 650;
        // Add slow random modulation to freq for smooth variation
        let freq = lastFreq + (Math.random() - 0.5) * 80 * calmness;
        freq = Math.min(Math.max(freq, 150), baseFreq);
        lastFreq = freq;

        // Filter cutoff varies with calmness & freq to keep ethereal warmth
        let cutoff = lastCutoff + (Math.random() - 0.5) * 300;
        cutoff = Math.min(Math.max(cutoff, 600), settings.filterFreq);
        lastCutoff = cutoff;

        // Create layered voice
        const voice = new Voice(freq, settings);
        voice.update(freq, cutoff);
        currentVoices.push(voice);

        // Remove old voices to keep things light & clean
        if (currentVoices.length > 15) {
          const oldVoice = currentVoices.shift();
          oldVoice.stop();
        }

        // Schedule next note: longer pause if calmness low (less chaotic)
        const nextInMs = 1200 - calmness * 800 + Math.random() * 400;

        setTimeout(generateNote, nextInMs);
      }

      generateNote();
    }

    function stopMusic() {
      if (!isPlaying) return;
      isPlaying = false;
      currentVoices.forEach(v => v.stop());
      currentVoices = [];
    }
  </script>
</body>
</html>
